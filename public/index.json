[
{
	"uri": "https://nnminhtan.github.io/",
	"title": "Automating Incident Response",
	"tags": [],
	"description": "",
	"content": "Automating Incident Response Overview This lab is designed to simulate and respond to a real-world cloud security incident involving a compromised EC2 instance within the AWS environment. The focus is on building and executing automated incident response (IR) playbooks to detect and remediate malicious activity without manual intervention, leveraging AWS-native tools and services.\nScenario Summary An adversary has successfully compromised an EC2 instance, potentially via a vulnerability such as an OS command injection. After gaining unauthorized access, the attacker:\nInstalls a TOR client to communicate anonymously with an external command-and-control (C2) server. Attempts to perform Bitcoin mining and establish a connection to a known malicious IP address. Automated Incident Response Playbook Approaches In this lab, we will implement two types of automated incident response (IR) playbooks using AWS-native services. Each approach provides distinct advantages and trade-offs depending on the complexity and duration of the remediation tasks.\n1. Lambda-based IR Playbook This approach uses a single AWS Lambda function to execute remediation actions as soon as an incident is detected. It is the simplest and fastest method to deploy. However, it comes with an important limitation:\nExecution time is capped at 15 minutes, which means it cannot accommodate long-running tasks, such as waiting for an EBS snapshot to complete or performing detailed forensic collection. Best suited for immediate and lightweight actions, such as tagging, isolating the instance via security group changes, or sending alerts. 2. Step Functions-based IR Playbook This method uses AWS Step Functions to orchestrate the incident response as a modular state machine, enabling a more flexible and robust IR process.\nUnlike Lambda, there is no strict execution timeout, allowing for complex, multi-step workflows that may span several minutes or even hours. Tasks can be broken into independent, manageable states, including parallel execution, retries, wait conditions, and failure handling logic. Ideal for scenarios requiring sequenced actions, such as taking snapshots, gathering forensic data, notifying multiple systems, and then terminating or quarantining the instance. By comparing both approaches, this lab highlights how AWS automation tools can be tailored to meet different response needs — from rapid reaction to comprehensive remediation pipelines.\nGoals of the Workshop By the end of this workshop, you will have learned how to:\nPerform automated basic incident response tasks focused on containment and forensic data collection. Understand the range of possible remediation actions and the effort involved in executing them. This workshop length is around 3hrs, even if you dont complete it visit the clean up resources part to avoid the fees.\nWorkshop Content Introduction Preparation Steps Configure Response Configure Automated Response Clean Up Resources "
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.1-single-lambda-response/3.1.1-create-iam-policies-and-roles/",
	"title": "Create IAM Policies and Roles",
	"tags": [],
	"description": "",
	"content": "Since you are already at the IAM dashboard for the last step, now headed to the policies and create one for the execution role\nCreate a policy for the execution role\nFirst click Create policy Click the json format and paste the following into the Policy editor and click Next { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;EC2Snapshot\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:AuthorizeSecurityGroupIngress\u0026#34;, \u0026#34;ec2:Describe*\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;ec2:CreateSecurityGroup\u0026#34;, \u0026#34;ec2:CreateTags\u0026#34;, \u0026#34;ec2:CreateSnapshots\u0026#34;, \u0026#34;ec2:CreateSnapshot\u0026#34;, \u0026#34;ec2:ModifyInstanceAttribute\u0026#34;, \u0026#34;ec2:StopInstances\u0026#34;, \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } The result should be like this. Name the policy : ec2instance-containment-with-forensics-policy and leave the rest unchanged, then Create policy. Create the execution role for the Lambda Function\nStill in the IAM dashboard, head to the roles in the left side panel, Select Create role The default Trusted entity type should be AWS service. Under Service or use case, Select Lambda and click Next. Add the prior created ec2instance-containment-with-forensics-policy policy and click next. Name the Role ec2instance-containment-with-forensics-role and leave every unchanged, click Create Role. If you done with that go to the next step which is Create Lambda Function\n"
},
{
	"uri": "https://nnminhtan.github.io/2-preparation/2.1-deploy-the-cloudformation-stack/",
	"title": "Deploy the CloudFormation stack",
	"tags": [],
	"description": "",
	"content": "To initiate the scenario and create the infrastructure we need to deploy a CloudFormation template.\nYou can download the example file here: The CloudFormation JSON file.\nAccess the CloudFormation\nSearch for CloudFormation. Select CloudFormation to open the CloudFormation Dashboard. In the CloudFormation Dashboard\nSelect Stacks. Click Create stack. In the Create stack interface, under Create stack\nChoose Choose an existing template. Under Specify template, select Upload a template file. Click Choose file and upload the cfn.json file above. Click Next. In the Specify stack details interface, under Specify stack details\nUnder Provide a stack name, Enter Stack name: AutomatedIncidentResponseWorkshop. Under Parameters, In Automatically enable GuardDuty? select Yes-Enable GuardDuty. Leave the other settings unchanged, Click Next. In the Configure stack options interface, under Capabilities\nCheck yes for 2 of the box below. In the Review and create:\nIf you follow the steps It\u0026rsquo;s should be right so scroll down and click the Submit button. Before moving on, make sure the stack is in a CREATE_COMPLETE status. This should take a couple minutes, so go grab a coffee while at it.\nIf the stack status is CREATE_COMPLETE go to the next step Set up Security Group\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.2-step-function-response/3.2.1-deploy-the-cloudformation-stack/",
	"title": "Deploy the CloudFormation stack",
	"tags": [],
	"description": "",
	"content": "To initiate the scenario and create the infrastructure we need to deploy a CloudFormation template.\nYou can download : The CloudFormation template file with the required architecture.\nAccess the CloudFormation\nSearch for CloudFormation. Select CloudFormation to open the CloudFormation Dashboard. In the CloudFormation Dashboard\nSelect Stacks. Click Create stack. In the Create stack interface, under Create stack\nChoose Choose an existing template. Under Specify template, select Upload a template file. Click Choose file and upload the IRWorkshop-StepFunctionsResponse.yaml file above. Click Next. In the Specify stack details interface, under Specify stack details\nUnder Provide a stack name, Enter Stack name: workshop-IR-StepFunctions. Under Parameters, Enter a valid email address and an optional prefix for the resouces that will be created. Click Next. In the Configure stack options interface, under Capabilities\nCheck yes for the box below. In the Review and create:\nIf you follow the steps It\u0026rsquo;s should be right so scroll down and click the Submit button. Before moving on, make sure the stack is in a CREATE_COMPLETE status. This should take a couple minutes, so go grab a coffee while at it.\nIf the stack status is CREATE_COMPLETE go to the next step Set up SNS subscription\n"
},
{
	"uri": "https://nnminhtan.github.io/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Automated Incident Response Playbook Approaches In this lab, we will implement two types of automated incident response (IR) playbooks using AWS-native services. Each approach provides distinct advantages and trade-offs depending on the complexity and duration of the remediation tasks.\nThis workshop is test in the region: us-east-1 (N. Virginia). This workshop length is around 3hrs, even if you dont complete it visit the clean up resources part to avoid the fees.\n1. Lambda-based IR Playbook This approach uses a single AWS Lambda function to execute remediation actions as soon as an incident is detected. It is the simplest and fastest method to deploy. However, it comes with an important limitation:\nExecution time is capped at 15 minutes, which means it cannot accommodate long-running tasks, such as waiting for an EBS snapshot to complete or performing detailed forensic collection. Best suited for immediate and lightweight actions, such as tagging, isolating the instance via security group changes, or sending alerts. 2. Step Functions-based IR Playbook This method uses AWS Step Functions to orchestrate the incident response as a modular state machine, enabling a more flexible and robust IR process.\nUnlike Lambda, there is no strict execution timeout, allowing for complex, multi-step workflows that may span several minutes or even hours. Tasks can be broken into independent, manageable states, including parallel execution, retries, wait conditions, and failure handling logic. Ideal for scenarios requiring sequenced actions, such as taking snapshots, gathering forensic data, notifying multiple systems, and then terminating or quarantining the instance. By comparing both approaches, this lab highlights how AWS automation tools can be tailored to meet different response needs — from rapid reaction to comprehensive remediation pipelines.\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.1-single-lambda-response/",
	"title": "Single Lambda response",
	"tags": [],
	"description": "",
	"content": "Configure for single Lambda response In this section you will learn how to implement an automated incident response action on a single AWS Lambda Function. This function will perform all the necessary actions in the same code.\nThe steps we will be performing are:\nCreate an IAM policy and attach it to the IAM role that the Lambda function will assume for the automated responses. Create the Lambda function. Test the Lambda function. Create an EventBridge rule that will call the Lambda function based on the GuardDuty findings. The architecture for this alternative is the following: Contents: Create IAM Policies and Roles Create Lambda Function Test Lambda Function Create EventBridge Rule "
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.1-single-lambda-response/3.1.2-create-lambda-function/",
	"title": "Create Lambda Function",
	"tags": [],
	"description": "",
	"content": " Create a Lambda Function\nIn the search bar look for Lambda, It should take we to the Lambda begin page Click Create a function Name the function : ec2instance-containment-with-forensics. Select the Runtime as : Python 3.9. Expand the Change default execution role, choose Use a existing role. Select the ec2instance-containment-with-forensics-role as execution role. The result should be like this, then click Create function Modify the prior created Lambda function\nClick the Configuration, then click the Edit button. Change the Timeout to 15 min, then save. Now we will create the environment variables to the lambda function Still in the Configuration, select the Environment variables and click Edit. Select Add environment variable. Key: ForensicsSG Value: sg-\u0026hellip;(the ID of your Forensics SG) They should be like as below. Then click save. Add the code for the Lambda Function\nClick the Code next to the Configuration. In the code editor, paste the following code. import boto3, json import time from datetime import date from botocore.exceptions import ClientError import os def lambda_handler(event, context): # Copyright 2022 - Amazon Web Services # Permission is hereby granted, free of charge, to any person obtaining a copy of this # software and associated documentation files (the \u0026#34;Software\u0026#34;), to deal in the Software # without restriction, including without limitation the rights to use, copy, modify, # merge, publish, distribute, sublicense, and/or sell copies of the Software, and to # permit persons to whom the Software is furnished to do so. # THE SOFTWARE IS PROVIDED \u0026#34;AS IS\u0026#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, # INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A # PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT # HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION # OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE # SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. # print(\u0026#39;## ENVIRONMENT VARIABLES\u0026#39;) # print(os.environ) # print(\u0026#39;## EVENT\u0026#39;) # print(event) response = \u0026#39;Error remediating the security finding.\u0026#39; try: # Gather Instance ID from CloudWatch event instanceID = event[\u0026#39;detail\u0026#39;][\u0026#39;resource\u0026#39;][\u0026#39;instanceDetails\u0026#39;][\u0026#39;instanceId\u0026#39;] print(\u0026#39;## INSTANCE ID: %s\u0026#39; % (instanceID)) # Get instance details client = boto3.client(\u0026#39;ec2\u0026#39;) ec2 = boto3.resource(\u0026#39;ec2\u0026#39;) instance = ec2.Instance(instanceID) instance_description = client.describe_instances(InstanceIds=[instanceID]) print(\u0026#39;## INSTANCE DESCRIPTION: %s\u0026#39; % (instance_description)) #------------------------------------------------------------------- # Protect instance from termination #------------------------------------------------------------------- ec2.Instance(instanceID).modify_attribute( DisableApiTermination={ \u0026#39;Value\u0026#39;: True }) ec2.Instance(instanceID).modify_attribute( InstanceInitiatedShutdownBehavior={ \u0026#39;Value\u0026#39;: \u0026#39;stop\u0026#39; }) #------------------------------------------------------------------- # Create tags to avoid accidental deletion of forensics evidence #------------------------------------------------------------------- ec2.create_tags(Resources=[instanceID], Tags=[{\u0026#39;Key\u0026#39;:\u0026#39;status\u0026#39;, \u0026#39;Value\u0026#39;:\u0026#39;isolated\u0026#39;}]) print(\u0026#39;## INSTANCE TAGS: %s\u0026#39; % (instance.tags)) #------------------------------------ ## Isolate Instance #------------------------------------ print(\u0026#39;quarantining instance -- %s, %s\u0026#39; % (instance.id, instance.instance_type)) # Change instance Security Group attribute to terminate connections and allow Forensics Team\u0026#39;s access instance.modify_attribute(Groups=[os.environ[\u0026#39;ForensicsSG\u0026#39;]]) print(\u0026#39;Instance ready for root cause analysis -- %s, %s\u0026#39; % (instance.id, instance.security_groups)) #------------------------------------ ## Create snapshots of EBS volumes #------------------------------------ description= \u0026#39;Isolated Instance:\u0026#39; + instance.id + \u0026#39; on account: \u0026#39; + event[\u0026#39;detail\u0026#39;][\u0026#39;accountId\u0026#39;] + \u0026#39; on \u0026#39; + date.today().strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;) SnapShotDetails = client.create_snapshots( Description=description, InstanceSpecification = { \u0026#39;InstanceId\u0026#39;: instanceID, \u0026#39;ExcludeBootVolume\u0026#39;: False } ) print(\u0026#39;Snapshot Created -- %s\u0026#39; % (SnapShotDetails)) response = \u0026#39;Instance \u0026#39; + instance.id + \u0026#39; auto-remediated\u0026#39; except ClientError as e: print(e) return response Then click on deploy, as shown below. You can review comments on the code to understand what it\u0026rsquo;s doing.\nIf you done with that, the next step which we will Test the Lambda Function.\n"
},
{
	"uri": "https://nnminhtan.github.io/2-preparation/",
	"title": "Preparation Steps",
	"tags": [],
	"description": "",
	"content": "We will prepare by creating an IAM user for testing and attaching necessary policies. You will enable Amazon GuardDuty, and deploy a CloudFormation template to create a sample infrastructure to simulate an attacker and a target.\nMake sure the account being use for this workshop it\u0026rsquo;s NOT a production account.\nContents: Deploy the CloudFormation stack Set up Security Group Create an IAM user for Testing "
},
{
	"uri": "https://nnminhtan.github.io/2-preparation/2.2-set-up-security-group/",
	"title": "Set up Security Group",
	"tags": [],
	"description": "",
	"content": "Next, we will create a Security group.\nAccess the Security group\nSearch for the Security group. Click Security group. Select the Create security group. In the Create security group interface, under Basic details\nUnder Security group name, set the name as : ForensicsSG. Make sure to set the VPC to (VPC-AutomatedIncidentResponeWorkshop) as shown below. In the Create security group interface, under Inbound rules and Outbound rules\nUnder the Inbound rules, add new Inbound rules and set as below. RDP TCP 3389 Source (your IP) Description(optional) : RDP for IR team. SSH TCP 22 Source (your IP) Description(optional) : SSH for IR team. Remove all of the Outbound rules as below. Click Create security group. Policy created successfully: After Security group creation is complete, copy the Security group ID and go to the next step Create an IAM user for Testing\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.2-step-function-response/3.2.2-sns-subscription/",
	"title": "SNS subscription",
	"tags": [],
	"description": "",
	"content": "As part of the CloudFormation stack you just created, you will receive a email like this in the address you entered during the template deployment:\nYou should click on the Confirm Subscription in order to be able to receive the notifications that the State Machine will send as part of the automated response. Once you confirm the subscription you should see the following message on the opened webpage:\nIt might take a few minutes for the email to be delivered. Also check the SPAM folder just in case.\nIf you done with that, the next step which we will Test the Step Functions.\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.2-step-function-response/",
	"title": "Step Function response",
	"tags": [],
	"description": "",
	"content": "Configure for Step Function response In this section you will learn how to implement an automated incident response action via a workflow implemented with Step Functions. The advantages of this approach are:\nNo timeout for the actions to be performed Almost all the API calls for the AWS Services are implemented and can be directly called without a line of code Graphical workflow definition More control over the different paths The steps we will be performing for this alternative are:\nDeploy a CloudFormation template that will create all the necessary resources Accept the SNS subscription in order to receive the email notifications Test the State Machine. Create an EventBridge rule that will call the State Machine based on the GuardDuty findings. The architecture for this alternative is the following: And the Step Function workflow graph is the following: A brief explanation of the workflow presented:\nCheck if an instance ID is present on the GuardDuty finding\nDepending on the GuardDuty finding severity:\nIf the severity is higher or equal to 8 then a SNS notification is sent to the registered email (the one used during the CloudFormation deployment). If the severity is lower than 8 then a Manual Approval email is sent to the registered email: If the Manual Approval is Rejected then the workflow is finished and no actions is taken. If the Manual Approval is Approved then the following actions are taken. Disable termination is applied to the EC2 instance.\nShutdown behavior is changed to the instance.\nThe ForensicSG Security Group is applied to the instance.\nA tag isolated is applied to the instance.\nThe workflow is finished.\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/",
	"title": "Configure-Response",
	"tags": [],
	"description": "",
	"content": "In this section you will learn how to implement an automated incident response action in two different ways:\nOn a single AWS Lambda function: this is the simplest way to execute the remediation, but it has as caveat that we can\u0026rsquo;t wait for tasks like snapshots to complete as we can hit the 15min Lambda timeout.\nOn a State Machine via Step Functions : this is a more complex yet more flexible option as we can configure the response in a modularized way. There is no limitation on neither the actions nor the time the State Machine can be in a running state.\nContents: Single Lambda response Step Function response "
},
{
	"uri": "https://nnminhtan.github.io/2-preparation/2.3-create-an-iam-user-for-testing/",
	"title": "Create an IAM user for Testing",
	"tags": [],
	"description": "",
	"content": "Create an IAM user for Testing In this section, we attach the policy to the previously created role to ensure the role has the appropriate permissions defined in the policy.\nAccess IAM Dashboard\nSearch for the IAM. Click it to access IAM Dashboard. Create a IAM policy in IAM Dashboard\nLook for Policies in the side panel, select Create policy. Under Specify permission within the Policy editor click the JSON to switch to JSON format and then paste the JSON below into the editor. { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;VisualEditor0\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Deny\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:TerminateInstances\u0026#34;, \u0026#34;ec2:DeleteTags\u0026#34;, \u0026#34;ec2:CreateTags\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Condition\u0026#34;: { \u0026#34;StringEquals\u0026#34;: { \u0026#34;aws:ResourceTag/status\u0026#34;: \u0026#34;isolated\u0026#34; } } } ] } After that click Next. In the Review and create under Policy details, name the policy : Deny-termination-of-isolated-instances. Leaves the rest unchanged, click the Create policy. This should take you back to the Policy Interface. In real life scenario the authors recommend using Service control policies (SCP)\nCreate a Group\nIn the Policy Interface, In the side panel you should see User groups access it. Click Create Group. Under Create user group, name the group : ec2-user. Under Attach permissions policies, attach these policies to the group : The AmazonEC2FullAccess AWS Managed Policy The prior created Deny-termination-of-isolated-instances Click Create group, the results should be like this. Create a user\nHead back in the side panel click the Users and click Create user. Under Specify user details, name the User name is : testuser. Select yes for the Provide user access to the AWS Management console. Select I want to create an IAM user, You can choose autogenerated password or custom password. You can unselect User must create a new password at next sign-in as shown below. Click next to go to the Set permission interface. Under Permissions options leave it as Add a user to group. Under User groups add the user to the prior created ec2-users. Proceed next to Create user. You should copy the password to a notepad or a text editor if you choose the autogenerated password avoid losing access to the account.\nAfter the user creation, the user should have permission like below This is just for demo purposes, to show that once the instance is tagged as isolated, the regular users with this policy will not be able to terminate the instance. In real life you should follow the best practice of using only temporary credentials, as per Well-Architected-Framework\u0026rsquo;s best practice\nAfter testuser creation is complete, head on to the next step Configure Response\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.1-single-lambda-response/3.1.3-test-lambda-function/",
	"title": "Test Lambda Function",
	"tags": [],
	"description": "",
	"content": "In this step we will test the Lambda Function that created previously.\nReview the comments on the code to understand what it\u0026rsquo;s doing.\nReview the main steps on the code. Note: this is just an example, more actions could be added. The code has several print functions that you can leave enabled to see the contents on CloudWatch Logs, or you can comment them out. Create test event for Lambda function\nIn the same Function code editor, Select Test this will open a Create new test event on the top, click on it. The panel Create new test event will open, name the test event : GuardDutyViaCWE. Copy this JSON below and paste in Event JSON, this JSON will need some modifications before you can run it. { \u0026#34;version\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;cd2d702e-ab31-411b-9344-793ce56b1bc7\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;GuardDuty Finding\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;aws.guardduty\u0026#34;, \u0026#34;account\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;1970-01-01T00:00:00Z\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;resources\u0026#34;: [], \u0026#34;detail\u0026#34;: { \u0026#34;schemaVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;accountId\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;partition\u0026#34;: \u0026#34;aws\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;b0baa89de4ab301f8d0a8c9a3dfd5726\u0026#34;, \u0026#34;arn\u0026#34;: \u0026#34;arn:aws:guardduty:us-east-1:\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;:detector/feb3c048238f682b8902532ec100b3fb/finding/b0baa89de4ab301f8d0a8c9a3dfd5726\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;UnauthorizedAccess:EC2/TorClient\u0026#34;, \u0026#34;resource\u0026#34;: { \u0026#34;instanceDetails\u0026#34;: { \u0026#34;instanceId\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Instance ID\u0026gt;\u0026gt;\u0026#34; } } } } Replace the AccountID for yours. Replace the Instance ID with the ID of the BasicLinuxTarget instance deployed by the CloudFormation template (below is how you can find the Instance ID). After replace all the Account ID and Instance ID, then save. Verify status before execution : check on the EC2 console what is the current status of the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; Can you answer the following questions? • Which Security Group does it have? • Which tags does it have ? • Is there any snapshot related to the instance? Press the test event just created, and verify the status after execution: of the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; Can you answer the following questions? • Has the Security Group changed? • Have the tags changed? • Has any new Snapshot been created? • Log in with a different Internet browser or using private mode, use the link on the IAM Dashboard (as seen below) and verify if you can delete the EC2 with the IAM user testuser that you created during the Setup steps. • Are you able to delete the instance? When you use the testuser and try to delete the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; it should have this error. When you are done with all the steps, head to the next part of the Workshop which is Create a EventBridge Rule\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.2-step-function-response/3.2.3-test-the-step-functions/",
	"title": "Test the Step Functions",
	"tags": [],
	"description": "",
	"content": "In this step we will test the Step Functions that created previously.\nGo to the Step Functions service and on States machines select the name of the newly created one PREFIX_StateMachine.\nSelect Start execution\nCopy this JSON below and paste in Input, this JSON will need some modifications before you can run it. { \u0026#34;version\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;cd2d702e-ab31-411b-9344-793ce56b1bc7\u0026#34;, \u0026#34;detail-type\u0026#34;: \u0026#34;GuardDuty Finding\u0026#34;, \u0026#34;source\u0026#34;: \u0026#34;aws.guardduty\u0026#34;, \u0026#34;account\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;1970-01-01T00:00:00Z\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;resources\u0026#34;: [], \u0026#34;detail\u0026#34;: { \u0026#34;schemaVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;accountId\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;\u0026#34;, \u0026#34;region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;partition\u0026#34;: \u0026#34;aws\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;b0baa89de4ab301f8d0a8c9a3dfd5726\u0026#34;, \u0026#34;arn\u0026#34;: \u0026#34;arn:aws:guardduty:us-east-1:\u0026lt;\u0026lt;Account ID\u0026gt;\u0026gt;:detector/feb3c048238f682b8902532ec100b3fb/finding/b0baa89de4ab301f8d0a8c9a3dfd5726\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Bitcoin-related domain name queried by EC2 instance \u0026lt;\u0026lt;Instance ID\u0026gt;\u0026gt;.\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;CryptoCurrency:EC2/BitcoinTool.B!DNS\u0026#34;, \u0026#34;severity\u0026#34;: 8, \u0026#34;resource\u0026#34;: { \u0026#34;instanceDetails\u0026#34;: { \u0026#34;instanceId\u0026#34;: \u0026#34;\u0026lt;\u0026lt;Instance ID\u0026gt;\u0026gt;\u0026#34; } } } } Replace the AccountID for yours. Replace the Instance ID with the ID of the BasicLinuxTarget instance deployed by the CloudFormation template (below is how you can find the Instance ID). After replace all the Account ID and Instance ID. Verify status before execution : check on the EC2 console what is the current status of the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; Can you answer the following questions? • Which Security Group does it have? • Which tags does it have ? • Is there any snapshot related to the instance? Press the Start execution, and verify the status after execution: of the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; Can you answer the following questions? • Has the Security Group changed? • Have the tags changed? • Has any new Snapshot been created? • Log in with a different Internet browser or using private mode, use the link on the IAM Dashboard (as seen below) and verify if you can delete the EC2 with the IAM user testuser that you created during the Setup steps. • Are you able to delete the instance? When you use the testuser and try to delete the instance \u0026ldquo;BasicLinuxTarget\u0026rdquo; it should have this error. Test the State Machine with a different severity\nFollow the same steps as before but change the severity field on the JSON event from 8 to 7. Is the workflow executed still the same? What changed? When you are done with all the steps, head to the next part of the Workshop which is Create a EventBridge Rule\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.1-single-lambda-response/3.1.4-create-eventbridge-rule/",
	"title": "Create EventBridge Rule",
	"tags": [],
	"description": "",
	"content": "In this step we will create a EventBridge Rule for create a snapshot for the BasicLinuxTarget.\nCreate EventBridge Rule Search for the EventBridge. This will take you to the EventBridge home, click on Create Rule. Name the rule is : gd-compromised-instance-remediation, the description is optional, then foward to the creation. Under Event pattern, Creation method click the Custom pattern(JSON editor) and paste the Json below into the editor.\n{ \u0026#34;source\u0026#34;: [\u0026#34;aws.guardduty\u0026#34;], \u0026#34;detail\u0026#34;: { \u0026#34;type\u0026#34;: [\u0026#34;UnauthorizedAccess:EC2/TorClient\u0026#34;, \u0026#34;Backdoor:EC2/C\u0026amp;CActivity.B!DNS\u0026#34;, \u0026#34;Trojan:EC2/DNSDataExfiltration\u0026#34;, \u0026#34;CryptoCurrency:EC2/BitcoinTool.B\u0026#34;, \u0026#34;CryptoCurrency:EC2/BitcoinTool.B!DNS\u0026#34;] } } The result should be like this then click Next. Select Lambda function as the target. Select the ec2instance-containment-with-forensics as the Function. (The result should be like this) Leave every unchanged and create the Rule. Make sure the instance is already isolated before taking snapshots otherwise you may end up with many snapshots created every 15 minutes (or 6H depending your GuardDuty setting). The authors recommend disabling this rule once you\u0026rsquo;ve completed the testing.\n"
},
{
	"uri": "https://nnminhtan.github.io/3-configure-response/3.2-step-function-response/3.2.4-create-eventbridge-rule/",
	"title": "Create EventBridge Rule",
	"tags": [],
	"description": "",
	"content": "In this step we will create a EventBridge Rule for create a snapshot for the BasicLinuxTarget.\nCreate EventBridge Rule Search for the EventBridge. This will take you to the EventBridge home, click on Create Rule. Name the rule is : gd-compromised-instance-remediation (if you still kept the old one then add this rule with -sf), the description is optional, then foward to the creation. Under Event pattern, Creation method click the Custom pattern(JSON editor) and paste the Json below into the editor. { \u0026#34;source\u0026#34;: [\u0026#34;aws.guardduty\u0026#34;], \u0026#34;detail\u0026#34;: { \u0026#34;type\u0026#34;: [\u0026#34;UnauthorizedAccess:EC2/TorClient\u0026#34;, \u0026#34;Backdoor:EC2/C\u0026amp;CActivity.B!DNS\u0026#34;, \u0026#34;Trojan:EC2/DNSDataExfiltration\u0026#34;, \u0026#34;CryptoCurrency:EC2/BitcoinTool.B\u0026#34;, \u0026#34;CryptoCurrency:EC2/BitcoinTool.B!DNS\u0026#34;] } } The result should be like this then click Next. Select Step Functions state machine as the target. Select the the State Machine that we tested before PREFIX_StateMachine as the Target. (The result should be like this) Leave every unchanged and create the Rule. Make sure the instance is already isolated before taking snapshots otherwise you may end up with many snapshots created every 15 minutes (or 6H depending your GuardDuty setting). The authors recommend disabling this rule once you\u0026rsquo;ve completed the testing.\n"
},
{
	"uri": "https://nnminhtan.github.io/4-configure-automated-response/",
	"title": "Configure Automated Response",
	"tags": [],
	"description": "",
	"content": "Configure Automated Response In this section you will know how to ingest sample findings using GuardDuty and use the input for the automated incident response process.\nIn the environment there is a \u0026ldquo;RedTeam\u0026rdquo; instance that will generate GuardDuty findings.\nGo to GuardDuty, select Settings.\nUnder Findings export options, the prequency should be update findings every 15 mins if you using the CloudFormation template. (If not Click Edit set the Frequency to set it to update every 15 mins). Then select findings.\nYou have to wait for a while for it to get the findings, also other service running might raise the cost if you don\u0026rsquo;t want to wait then you can skip this (optional!). But here is the sample results should look like.\nTest Automated Response To test the automated response, you could\nWait for the RedTeam instance to trigger the event, as it\u0026rsquo;s using the GuardDuty tester scripts\nYou could manually launch a Windows instance creating a new SG that allows RDP (3389) access from your IP Address, and simulate outgoing malware connections by:\nInstalling a TOR Browser Connecting to mining pools like pool.minergate.com You could manually launch a Linux instance creating a new SG that allows SSH (22) access from your IP Address, and call the fake domain introduced in our threat intelligence feeds that is used to test Command \u0026amp; Control Findings with the following command:\ndig GuardDutyC2ActivityB.com any Wait a couple of minutes (it can take up to 20 min) for GuardDuty to generate the findings . If you choose Linux instances, you can use EC2 Instance Connect to get a terminal on the instance or connecting using SSH.\nTo connect to the RedTeam instance you can use Systems Manager Session Manager, but you\u0026rsquo;d have to add the instance profile for SSM, and reboot the instance.\n"
},
{
	"uri": "https://nnminhtan.github.io/5-clean-up/",
	"title": "Cleanup Resources",
	"tags": [],
	"description": "",
	"content": "Cleaning up resources In order to prevent charges to your account we recommend cleaning up the infrastructure that was created during this workshop. If you plan to keep things running so you can examine the workshop later, remember to do the cleanup when you are done.\nPlease note that you will need to manually delete some resources before you delete the CloudFormation stacks, so please do the following steps in order.\nDisable termination protection for the applicable EC2 instances.\nOpen the EC2 console. Select the instance. Click on Actions, Instance settings, change termination protection. Uncheck the Enable checkbox, click Save. Delete the Cloudformation stack.\nGo to the AWS CloudFormation console. Select the appropiate stack (remember that depending on the automated responses deployed you might have 2 stacks and 1 nested stack). Click Delete. Make sure the Stack delete status is DELETE_COMPLETE, this could take a while.\nCheck if Amazon GuardDuty was disabled automatically or you need to disable it manually.\nGo to the GuardDuty console. Click on Settings (on the left panel menu). Scroll down. Click Disable GuardDuty. Disabling GuardDuty will remove its data.\nVerify and delete any remaining EC2 snapshots generated. "
},
{
	"uri": "https://nnminhtan.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://nnminhtan.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]